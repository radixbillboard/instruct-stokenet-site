var E=Object.defineProperty;var g=(e,t,s)=>t in e?E(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var o=(e,t,s)=>(g(e,typeof t!="symbol"?t+"":t,s),s);import{s as A,c as m}from"./entityCache.paPPdksK.js";import{d as u,w as l}from"./index.CEWHKPF1.js";import{c as T,L as v}from"./Button.imn1sr_n.js";import{W as p}from"./scheduler.ZqBsD1eN.js";let r;const C=new Uint8Array(16);function L(){if(!r&&(r=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!r))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return r(C)}const n=[];for(let e=0;e<256;++e)n.push((e+256).toString(16).slice(1));function w(e,t=0){return n[e[t+0]]+n[e[t+1]]+n[e[t+2]]+n[e[t+3]]+"-"+n[e[t+4]]+n[e[t+5]]+"-"+n[e[t+6]]+n[e[t+7]]+"-"+n[e[t+8]]+n[e[t+9]]+"-"+n[e[t+10]]+n[e[t+11]]+n[e[t+12]]+n[e[t+13]]+n[e[t+14]]+n[e[t+15]]}const I=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),y={randomUUID:I};function _(e,t,s){if(y.randomUUID&&!t&&!e)return y.randomUUID();e=e||{};const i=e.random||(e.rng||L)();if(i[6]=i[6]&15|64,i[8]=i[8]&63|128,t){s=s||0;for(let d=0;d<16;++d)t[s+d]=i[d];return t}return w(i)}const U=`${v}entities-last-use`;class S{constructor(){o(this,"connectedAccountEntities",u(T,t=>t.map(s=>({address:s.address,shortenedAddress:A(s.address),entityVariant:"Component",label:s.label,origin:{type:"ConnectedWallet",appearanceId:s.appearanceId},isTrusted:!0,details:{type:"Component"}}))));o(this,"entitiesLastUsedTimestamps");o(this,"availableEntities");const t=localStorage.getItem(U);t?this.entitiesLastUsedTimestamps=l(JSON.parse(t)):this.entitiesLastUsedTimestamps=l({}),this.availableEntities=u([m.cachedEntities,this.connectedAccountEntities,this.entitiesLastUsedTimestamps],([s,i,d])=>{const c=new Map;for(const a of s)c.set(a.address,{...a,lastUsedTimestamp:d[a.address]??0});for(const a of i)c.set(a.address,{...a,lastUsedTimestamp:d[a.address]??0});return[...c.values()].toSorted((a,h)=>h.lastUsedTimestamp-a.lastUsedTimestamp)})}async useEntity(t){const s=p(this.entitiesLastUsedTimestamps);if(s[t]=new Date().getTime(),this.entitiesLastUsedTimestamps.set(s),localStorage.setItem(U,JSON.stringify(s)),new Set(p(this.connectedAccountEntities).map(c=>c.address)).has(t))p(this.connectedAccountEntities).find(c=>c.address===t);else return await m.loadAndCacheEntities([{address:t,origin:{type:"User"}}]),m.getCachedEntity(t)}}const O=new S;export{O as e,_ as v};
