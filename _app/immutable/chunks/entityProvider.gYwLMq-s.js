var E=Object.defineProperty;var h=(e,t,n)=>t in e?E(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var c=(e,t,n)=>(h(e,typeof t!="symbol"?t+"":t,n),n);import{u as A,g as T,e as p}from"./entityCache.MMyPzm4R.js";import{d as u,w as l}from"./index.Hduz1s-6.js";import{c as v,L as w}from"./caching.y0CrmXZh.js";import{a0 as m}from"./scheduler.3290unkr.js";let o;const L=new Uint8Array(16);function S(){if(!o&&(o=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!o))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return o(L)}const i=[];for(let e=0;e<256;++e)i.push((e+256).toString(16).slice(1));function I(e,t=0){return i[e[t+0]]+i[e[t+1]]+i[e[t+2]]+i[e[t+3]]+"-"+i[e[t+4]]+i[e[t+5]]+"-"+i[e[t+6]]+i[e[t+7]]+"-"+i[e[t+8]]+i[e[t+9]]+"-"+i[e[t+10]]+i[e[t+11]]+i[e[t+12]]+i[e[t+13]]+i[e[t+14]]+i[e[t+15]]}const x=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),y={randomUUID:x};function V(e,t,n){if(y.randomUUID&&!t&&!e)return y.randomUUID();e=e||{};const a=e.random||(e.rng||S)();if(a[6]=a[6]&15|64,a[8]=a[8]&63|128,t){n=n||0;for(let s=0;s<16;++s)t[n+s]=a[s];return t}return I(a)}const g=`${w}entities-last-use`;class C{constructor(){c(this,"connectedAccountEntities",A(u(v,async t=>{const n=new Map(t.map(s=>[s.address,s]));return[...(await T.loadScryptoEntities(t.map(s=>({address:s.address,origin:{type:"ConnectedWallet",appearanceId:s.appearanceId}})))).values()].map(s=>({...s,label:n.get(s.address).label}))}),[]));c(this,"entitiesLastUsedTimestamps");c(this,"availableEntities");const t=localStorage.getItem(g);t?this.entitiesLastUsedTimestamps=l(JSON.parse(t)):this.entitiesLastUsedTimestamps=l({}),this.availableEntities=u([p.cachedEntities,this.connectedAccountEntities,this.entitiesLastUsedTimestamps],([n,a,s])=>{const r=new Map;for(const d of n)r.set(d.address,{...d,lastUsedTimestamp:s[d.address]??0});for(const d of a)r.set(d.address,{...d,lastUsedTimestamp:s[d.address]??0});return[...r.values()].toSorted((d,U)=>U.lastUsedTimestamp-d.lastUsedTimestamp)})}async useEntity(t){const n=m(this.entitiesLastUsedTimestamps);return n[t]=new Date().getTime(),this.entitiesLastUsedTimestamps.set(n),localStorage.setItem(g,JSON.stringify(n)),this.getEntity(t)}async getEntity(t){return new Set(m(this.connectedAccountEntities).map(s=>s.address)).has(t)?m(this.connectedAccountEntities).find(s=>s.address===t):p.getEntity(t,{type:"User"})}}const B=new C;export{B as e,V as v};
