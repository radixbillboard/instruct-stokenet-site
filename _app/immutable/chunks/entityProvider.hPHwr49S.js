var E=Object.defineProperty;var h=(e,t,n)=>t in e?E(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var d=(e,t,n)=>(h(e,typeof t!="symbol"?t+"":t,n),n);import{u as A,g as T,e as p}from"./entityCache._D5fLVbA.js";import{d as u,w as l}from"./index.79jDLsWO.js";import{c as v,L as w}from"./caching.Uj6Q-cAO.js";import{X as m}from"./scheduler.nfizOy6U.js";let o;const L=new Uint8Array(16);function S(){if(!o&&(o=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!o))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return o(L)}const i=[];for(let e=0;e<256;++e)i.push((e+256).toString(16).slice(1));function I(e,t=0){return i[e[t+0]]+i[e[t+1]]+i[e[t+2]]+i[e[t+3]]+"-"+i[e[t+4]]+i[e[t+5]]+"-"+i[e[t+6]]+i[e[t+7]]+"-"+i[e[t+8]]+i[e[t+9]]+"-"+i[e[t+10]]+i[e[t+11]]+i[e[t+12]]+i[e[t+13]]+i[e[t+14]]+i[e[t+15]]}const b=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),y={randomUUID:b};function V(e,t,n){if(y.randomUUID&&!t&&!e)return y.randomUUID();e=e||{};const a=e.random||(e.rng||S)();if(a[6]=a[6]&15|64,a[8]=a[8]&63|128,t){n=n||0;for(let s=0;s<16;++s)t[n+s]=a[s];return t}return I(a)}const g=`${w}entities-last-use`;class x{constructor(){d(this,"connectedAccountEntities",A(u(v,async t=>{const n=new Map(t.map(s=>[s.address,s]));return[...(await T.loadScryptoEntities(t.map(s=>({address:s.address,origin:{type:"ConnectedWallet",appearanceId:s.appearanceId}})))).values()].map(s=>({...s,label:n.get(s.address).label}))}),[]));d(this,"entitiesLastUsedTimestamps");d(this,"availableEntities");this.connectedAccountEntities.subscribe(()=>{});const t=localStorage.getItem(g);t?this.entitiesLastUsedTimestamps=l(JSON.parse(t)):this.entitiesLastUsedTimestamps=l({}),this.availableEntities=u([p.cachedEntities,this.connectedAccountEntities,this.entitiesLastUsedTimestamps],([n,a,s])=>{const r=new Map;for(const c of n)r.set(c.address,{...c,lastUsedTimestamp:s[c.address]??0});for(const c of a)r.set(c.address,{...c,lastUsedTimestamp:s[c.address]??0});return[...r.values()].toSorted((c,U)=>U.lastUsedTimestamp-c.lastUsedTimestamp)})}async useEntity(t){const n=m(this.entitiesLastUsedTimestamps);return n[t]=new Date().getTime(),this.entitiesLastUsedTimestamps.set(n),localStorage.setItem(g,JSON.stringify(n)),this.getEntity(t)}async getEntity(t){return new Set(m(this.connectedAccountEntities).map(s=>s.address)).has(t)?m(this.connectedAccountEntities).find(s=>s.address===t):p.getEntity(t,{type:"User"})}}const B=new x;export{B as e,V as v};
